# 硬件处理 #
不同的外部设备、不同的体系结构、不同的OS其中断实现机制都有差别，本文对应的OS为linux3.4版本，外部设备为PCI设备、体系结构为X86。

## 概览 ##
中断让外设能够通知CPU他需要获得服务(让CPU执行指定的中断服务例程ISR)。为了达到这个目的，首先要为中断执行做好准备，完成初始化相关的操作。包括： 

1. 初始化中断控制器等相关器件(OS初始化过程中完成)；
2. 配置并使能外部设备(比如使用pci_enable_msix)，得到irq号；在这个操作过程中，内核需要完成的大致操作是：

- 确定该中断的执行CPU，并在对应CPU上建立vector和irq号的对应关系(利用全局per-cpu变量vector_irq)，cpu变量vector_irq的定义如下：

``` c
typedef struct irq_desc* vector_irq_t[NR_VECTORS];
DECLARE_PER_CPU(vector_irq_t, vector_irq);
```

arch/x86/include/asm/irq_vectors.h 对中断vector做了阐述：

```
/*
 * Linux IRQ vector layout.
 *
 * There are 256 IDT entries (per CPU - each entry is 8 bytes) which can
 * be defined by Linux. They are used as a jump table by the CPU when a
 * given vector is triggered - by a CPU-external, CPU-internal or
 * software-triggered event.
 *
 * Linux sets the kernel code address each entry jumps to early during
 * bootup, and never changes them. This is the general layout of the
 * IDT entries:
 *
 *  Vectors   0 ...  31 : system traps and exceptions - hardcoded events
 *  Vectors  32 ... 127 : device interrupts
 *  Vector  128         : legacy int80 syscall interface
 *  Vectors 129 ... INVALIDATE_TLB_VECTOR_START-1 except 204 : device interrupts
 *  Vectors INVALIDATE_TLB_VECTOR_START ... 255 : special interrupts
 *
 * 64-bit x86 has per CPU IDT tables, 32-bit has one shared IDT table.
 *
 * This file enumerates the exact layout of them:
 */
```
- 配置中断控制器(I/OAPIC、PIR等)，可能还需要设置外部设备(比如设置MSI Capacity registers)；
- 为对应的irq_desc初始化正确的handle_irq接口(通用逻辑接口)；
- 为对应的irq_desc初始化正确的底层chip操作接口。

3. 使用request_irq号为该中断号指定一个服务例程；

完成了以上的初始化操作，在外设中断到来的时候，为该中断指定的ISR(Interrupt Service Routines)就能得到执行，这个执行过程大致如下：

1. 外设根据各自的配置，产生中断信号或者中断消息(MSI，INT# message)。 
2. 中断控制器从外设获取中断电信号或者中断消息，把它翻译为vector(CPU使用这个参数来决定是谁发生了中断，要如何处理)并提交到CPU。 
3. 对X86系统，CPU利用从中断控制器获取到的vector为索引，查询IDT (interrupt descriptor table)得到该中断的处理接口(对linux，是在entry_64.s中定义的函数common_interrupt接口)并执行。 
4. 在linux定义的common_interrupt接口中，执行完中断执行环境建立后，会进入generic interrupt layer执行，其首先通过vector查找到irq和对应的irq_desc结构，并执行该结构的handle_irq接口，这个接口就是generic interrupt layer的通用逻辑接口，比如handle_edge_irq/handle_level_irq等；在中断执行的通用逻辑接口中，会通过irq_desc::action调用外设指定的ISR。 
在linux中可以通过/proc/interrupts查看当前系统中所有中断的统计信息，在/proc/irq/xxx(中断号)下面，可以看到该中断的详细信息。

## 中断相关硬件 ##
这里的描述很多来自INTEL的文档《Intel Software developer’s Manual, system programming guide》和《PCI Express System Architecture》
### 中断控制器 ###
中断控制器的功能是：把外设的中断信号，转换成CPU能够明白的vector，并完成中断执行控制，确保在合适的时机把中断提交给CPU执行。对这部分内容，《interrupt in linux》有详细的描述。 
1. 8259A： 
每个8259A有8个管脚，每个管脚对应其连接的CPU的IDT中的一个vector，单独使用8259A，其硬件连线就决定了对设备vector的使用。典型的场景是使用两个8259A级联，理论最多16个中断号(就是ISA IRQs)，实际能提供对15个中断线的处理(master的IRQ2用于连接slave),其具体的分配见下图。 
2. PIR： 
用于完成输入的信号到输出信号的映射。在下图中PIR被用于完成多个PCI设备的INT#信号到8259A对应引脚的路由。对应这种连接方式，在PCI设备初始化的时候，OS会根据BISO提供的信息设置PIR，把INT#路由到O0-O3中正确的管脚，从而体现到8259A的正确管脚(对应了vector)，这样INT#信号就被转换为vector并提交到CPU。由于可能有较多的PCI设备，而PIR的输入/出错管脚有限，所以连接到相同输入关键的INT#会共享一个中断。 

![8259&PIR](http://o8xc4jzcp.bkt.clouddn.com/8259-pir)

3. I/O APIC
  每个I/O APIC提供24个管脚，能够和外部设备的中断线连接，每个管脚都可以通过配RTE(Redirection table entry)配置对应的vector。其功能是：根据内部的PRT表（Programmable Redirection Table）把外部设备的中断请求，翻译为local APIC的interrupt message，并按照配置的vector，发送给指定的local APIC处理(在SMP系统，存在多个CPU，也就有多个local APIC)。通常的配置方式是：第一个I/O APIC的前16个管脚，配置来处理之前的ISA IRQs，其它外设比如PCI设备，则直接使用其他管脚连接。 

  与8259A不同，I/O APIC的管脚没有优先级，但这并不意味着APIC系统没有硬件优先级，设备的优先级由它对应的vector决定，优先级的控制功能放到了LAPIC中，我们在后面会看到。

  要搞清楚IOAPIC是怎么工作的，PRT表是关键，下表列出了RTE的格式 :

  | Bit   | 描述                                                         |
  | ----- | ------------------------------------------------------------ |
  | 63:56 | DestinationField，目的字段， R/W（可读写） 。根据DestinationFiled（见下）值的不同，该字段值的意义不同，它有两个意义：<br>PhysicalMode（ DestinationMode为0时） ： 其值为APICID，用于标识一个唯一的APIC。<br>LogicalMode（ DestinationMode为1时） ：其值根据LAPIC的不同配置，代表一组CPU（具体见LAPIC相关内容) |
  | 55:17 | 预留未用                                                     |
  | 16    | InterruptMask，中断屏蔽位， R/W。置一时，对应的中断管脚被屏蔽，这时产生的中断将被忽略。清零时，对应管脚产生的中断被发送至LAPIC |
  | 15    | Trigger Mode，触发模式，R/W。指明该管脚的的中断由什么方式触发。1：Level，电平触发；2：Edge，边沿触发。 |
  | 14    | Remote IRR，远程 IRR，RO（只读）。只对level触发的中断有效，当该中断是edge触发时，该值代表的意义未定义。当中断是level触发时，LAPIC接收了该中断，该位置一，LAPIC写EOI 时，该位清零。 |
  | 13    | Interrupt Input Pin Polarity（INTPOL），中断管脚的极性，R/W。指定该管脚的有效电平是高电平还是低电平。0：高电平；1：低电平。 |
  | 12    | Delivery Status，传送状态，RO。0：IDEL，当前没有中断；1：Send Pending，IOAPIC 已经收到该中断，但由于某种原因该中断还未发送给LAPIC |
  | 11    | Destination Mode，目的地模式，R/W。0：Physical Mode，解释见 Destination Field；1：Logical Mode，同上。 |
  | 10:8  | Delivery Mode，传送模式，R/W。用于指定该中断以何种方式发送给目的 APIC，各种模式需要和相应的触发方式配合。选的模式如下， 字段相应的值以二进制表示:<br>Fixed： 000b，发送给DestinationFiled列出的所有CPU， level、 edge触发均可。<br>LowestPriority： 001b， 发送给DestinationFiled列出的CPU中， 优先级最低的CPU（ CPU的优先级见LAPIC相关内容） 。 Level、 edge均可<br>SMI： 010b， SystemManagementInterrupt，系统管理中断。只能为 edge触发，并且vector字段写0<br>NMI： 100b， NoneMaskInterrupt，不可屏蔽中断。发送给DestinationField列出的所有CPU， Vector字段值被忽略。 NMI是edge触发， TriggerMode字段中的值对NMI无影响，但建议配置成edge。<br>INIT： 101b，发送给DestinationFiled列出的所有CPU， LAPIC收到后执行INIT中断（详细信息参考相关CPUspec中INIT中断一节） 。触发模式同NMI。<br>ExtINT： 111b，发送给DestinationFiled列出的所有CPU。 CPU收到该中断后， 认为这是一个PIC发送的中断请求，并回应INTA信号（该INTA脚连接到的是与该管脚相连的PIC上，而非IOAPIC上）<br>笔者： ExtINT用于PIC接在APIC上的情况，见后面的VirtualWireMod |
  | 7:0   | Interrupt Vector，中断向量，R/W。指定该中断对应的vector，范围从10h到FEh。 |

  

4. local APIC
  其负责处理IPI(inter-process interrupt)、直接连接的中断处理、接收和处理interrupt message，每个CPU有自己的local APIC。 
  对应I/O APIC和local APIC的组合，其连接方式见下图：
![](http://o8xc4jzcp.bkt.clouddn.com/IOAPIC&LAPIC)
对于目前的LAPIC来说，它可能从以下几个来源接收到中断：
- Locally connected I/O devices：这个主要是指通过local interrupt pins (LINT0 and LINT1)直接和处理器相连的I/O设备
- APIC timer generated interrupts：LAPIC可以通过编程设置某个counter，在固定时间内向处理器发送中断
- Performance monitoring counter interrupts：这个是指处理器中的性能计数器在发生overflow事件的时候向处理器发送中断进行通知
- Thermal Sensor interrupts：这个是由温度传感器触发的中断
- APIC internal error interrupts：这个是LAPIC内部错误触发的中断
- Externally connected I/O devices：这个是指外部设备通过IOAPIC和LAPIC进行相连
- Inter-processor interrupts (IPIs)：这个是指处理器之间通过IPI的方式进行中断的发送和接收



针对X86中断控制器硬件和linux对这些硬件的初始化，在《interrupt in linux》中有很详细的描述。
