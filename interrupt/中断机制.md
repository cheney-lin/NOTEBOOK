# 硬件处理 #
不同的外部设备、不同的体系结构、不同的OS其中断实现机制都有差别，本文对应的OS为linux3.4版本，外部设备为PCI设备、体系结构为X86。

## 概览 ##
中断让外设能够通知CPU他需要获得服务(让CPU执行指定的中断服务例程ISR)。为了达到这个目的，首先要为中断执行做好准备，完成初始化相关的操作。包括： 

1. 初始化中断控制器等相关器件(OS初始化过程中完成)；
2. 配置并使能外部设备(比如使用pci_enable_msix)，得到irq号；在这个操作过程中，内核需要完成的大致操作是：

- 确定该中断的执行CPU，并在对应CPU上建立vector和irq号的对应关系(利用全局per-cpu变量vector_irq)，cpu变量vector_irq的定义如下：

``` c
typedef struct irq_desc* vector_irq_t[NR_VECTORS];
DECLARE_PER_CPU(vector_irq_t, vector_irq);
```

arch/x86/include/asm/irq_vectors.h 对中断vector做了阐述：

```
/*
 * Linux IRQ vector layout.
 *
 * There are 256 IDT entries (per CPU - each entry is 8 bytes) which can
 * be defined by Linux. They are used as a jump table by the CPU when a
 * given vector is triggered - by a CPU-external, CPU-internal or
 * software-triggered event.
 *
 * Linux sets the kernel code address each entry jumps to early during
 * bootup, and never changes them. This is the general layout of the
 * IDT entries:
 *
 *  Vectors   0 ...  31 : system traps and exceptions - hardcoded events
 *  Vectors  32 ... 127 : device interrupts
 *  Vector  128         : legacy int80 syscall interface
 *  Vectors 129 ... INVALIDATE_TLB_VECTOR_START-1 except 204 : device interrupts
 *  Vectors INVALIDATE_TLB_VECTOR_START ... 255 : special interrupts
 *
 * 64-bit x86 has per CPU IDT tables, 32-bit has one shared IDT table.
 *
 * This file enumerates the exact layout of them:
 */
```
- 配置中断控制器(I/OAPIC、PIR等)，可能还需要设置外部设备(比如设置MSI Capacity registers)；
- 为对应的irq_desc初始化正确的handle_irq接口(通用逻辑接口)；
- 为对应的irq_desc初始化正确的底层chip操作接口。

3. 使用request_irq号为该中断号指定一个服务例程；

完成了以上的初始化操作，在外设中断到来的时候，为该中断指定的ISR(Interrupt Service Routines)就能得到执行，这个执行过程大致如下：

1. 外设根据各自的配置，产生中断信号或者中断消息(MSI，INT# message)。 
2. 中断控制器从外设获取中断电信号或者中断消息，把它翻译为vector(CPU使用这个参数来决定是谁发生了中断，要如何处理)并提交到CPU。 
3. 对X86系统，CPU利用从中断控制器获取到的vector为索引，查询IDT (interrupt descriptor table)得到该中断的处理接口(对linux，是在entry_64.s中定义的函数common_interrupt接口)并执行。 
4. 在linux定义的common_interrupt接口中，执行完中断执行环境建立后，会进入generic interrupt layer执行，其首先通过vector查找到irq和对应的irq_desc结构，并执行该结构的handle_irq接口，这个接口就是generic interrupt layer的通用逻辑接口，比如handle_edge_irq/handle_level_irq等；在中断执行的通用逻辑接口中，会通过irq_desc::action调用外设指定的ISR。 
在linux中可以通过/proc/interrupts查看当前系统中所有中断的统计信息，在/proc/irq/xxx(中断号)下面，可以看到该中断的详细信息。

## 中断相关硬件 ##
这里的描述很多来自INTEL的文档《Intel Software developer’s Manual, system programming guide》和《PCI Express System Architecture》
### 中断控制器 ###
中断控制器的功能是：把外设的中断信号，转换成CPU能够明白的vector，并完成中断执行控制，确保在合适的时机把中断提交给CPU执行。对这部分内容，《interrupt in linux》有详细的描述。 
1. 8259A： 
每个8259A有8个管脚，每个管脚对应其连接的CPU的IDT中的一个vector，单独使用8259A，其硬件连线就决定了对设备vector的使用。典型的场景是使用两个8259A级联，理论最多16个中断号(就是ISA IRQs)，实际能提供对15个中断线的处理(master的IRQ2用于连接slave),其具体的分配见下图。 
2. PIR： 
用于完成输入的信号到输出信号的映射。在下图中PIR被用于完成多个PCI设备的INT#信号到8259A对应引脚的路由。对应这种连接方式，在PCI设备初始化的时候，OS会根据BISO提供的信息设置PIR，把INT#路由到O0-O3中正确的管脚，从而体现到8259A的正确管脚(对应了vector)，这样INT#信号就被转换为vector并提交到CPU。由于可能有较多的PCI设备，而PIR的输入/出错管脚有限，所以连接到相同输入关键的INT#会共享一个中断。 

![8259&PIR](http://o8xc4jzcp.bkt.clouddn.com/8259-pir)

3. I/O APIC
  每个I/O APIC提供24个管脚，能够和外部设备的中断线连接，每个管脚都可以通过配RTE(Redirection table entry)配置对应的vector。其功能是：根据内部的PRT表（Programmable Redirection Table）把外部设备的中断请求，翻译为local APIC的interrupt message，并按照配置的vector，发送给指定的local APIC处理(在SMP系统，存在多个CPU，也就有多个local APIC)。通常的配置方式是：第一个I/O APIC的前16个管脚，配置来处理之前的ISA IRQs，其它外设比如PCI设备，则直接使用其他管脚连接。 

  与8259A不同，I/O APIC的管脚没有优先级，但这并不意味着APIC系统没有硬件优先级，设备的优先级由它对应的vector决定，优先级的控制功能放到了LAPIC中，我们在后面会看到。

  要搞清楚IOAPIC是怎么工作的，PRT表是关键，下表列出了RTE的格式 :

  | Bit   | 描述                                                         |
  | ----- | ------------------------------------------------------------ |
  | 63:56 | DestinationField，目的字段， R/W（可读写） 。根据DestinationFiled（见下）值的不同，该字段值的意义不同，它有两个意义：<br>PhysicalMode（ DestinationMode为0时） ： 其值为APICID，用于标识一个唯一的APIC。<br>LogicalMode（ DestinationMode为1时） ：其值根据LAPIC的不同配置，代表一组CPU（具体见LAPIC相关内容) |
  | 55:17 | 预留未用                                                     |
  | 16    | InterruptMask，中断屏蔽位， R/W。置一时，对应的中断管脚被屏蔽，这时产生的中断将被忽略。清零时，对应管脚产生的中断被发送至LAPIC |
  | 15    | Trigger Mode，触发模式，R/W。指明该管脚的的中断由什么方式触发。1：Level，电平触发；2：Edge，边沿触发。 |
  | 14    | Remote IRR，远程 IRR，RO（只读）。只对level触发的中断有效，当该中断是edge触发时，该值代表的意义未定义。当中断是level触发时，LAPIC接收了该中断，该位置一，LAPIC写EOI 时，该位清零。 |
  | 13    | Interrupt Input Pin Polarity（INTPOL），中断管脚的极性，R/W。指定该管脚的有效电平是高电平还是低电平。0：高电平；1：低电平。 |
  | 12    | Delivery Status，传送状态，RO。0：IDEL，当前没有中断；1：Send Pending，IOAPIC 已经收到该中断，但由于某种原因该中断还未发送给LAPIC |
  | 11    | Destination Mode，目的地模式，R/W。0：Physical Mode，解释见 Destination Field；1：Logical Mode，同上。 |
  | 10:8  | Delivery Mode，传送模式，R/W。用于指定该中断以何种方式发送给目的 APIC，各种模式需要和相应的触发方式配合。选的模式如下， 字段相应的值以二进制表示:<br>**Fixed**： 000b，发送给DestinationFiled列出的所有CPU， level、 edge触发均可。<br>LowestPriority： 001b， 发送给DestinationFiled列出的CPU中， 优先级最低的CPU（ CPU的优先级见LAPIC相关内容） 。 Level、 edge均可<br>**SMI**： 010b， System Management Interrupt，系统管理中断。只能为 edge触发，并且vector字段写0<br>**NMI**： 100b， None Mask Interrupt，不可屏蔽中断。发送给Destination Field列出的所有CPU， Vector字段值被忽略。 NMI是edge触发， Trigger Mode字段中的值对NMI无影响，但建议配置成edge。<br>**INIT**： 101b，发送给Destination Filed列出的所有CPU， LAPIC收到后执行INIT中断（详细信息参考相关CPUspec中INIT中断一节） 。触发模式同NMI。<br>**ExtINT**： 111b，发送给DestinationFiled列出的所有CPU。 CPU收到该中断后， 认为这是一个PIC发送的中断请求，并回应INTA信号（该INTA脚连接到的是与该管脚相连的PIC上，而非IOAPIC上）<br>笔者： ExtINT用于PIC接在APIC上的情况，见后面的VirtualWireMod |
  | 7:0   | Interrupt Vector，中断向量，R/W。指定该中断对应的vector，范围从10h到FEh。 |

  **IOAPIC发出的中断消息是如何找到LAPIC的？**

  RTE中的 DestinationField用于指定由哪个APIC接收，并且分为Physical和Logical两种模式。对于 LAPIC，两种模式有着不同的意义。

  **Physical模式**： 在该模式下，RTE中的DestinationField表示的是LAPICID。 对于 LAPIC 来说，系统在RESET后，都会分配一个唯一的ID用作标识。在X86平台下，我们可以通 过LAPICID寄存器得到它。

  操作系统或BIOS，通常会使用LAPICID唯一的标识一个CPU。在Pentium系列和P6 架构中， 由于APIC BUS最多只支持15个LAPICID， 即一个MP平台最多只能有15个CPU， RTE中的destination field表示LAPICID时只用了4bit， LAPICID寄存器也只有4bit可用。 对于Pentium4和Xeon系列， APICID被扩展至**8bit**，最多支持255个LAPIC。系统RESET 后， 可以用CPUID指令(EAX写参数1， EBX的24~31即为返回的ID)获得默认LAPICID。 某些CPU允许软件更改默认的ID号，但通常来说，软件应该避免这样的行为。无论何时， CPUID指令返回的都是系统RESET后默认分配的LAPICID， 即使当前的LAPICID寄存器 已经被软件更改过。

  当中断消息通过Physical模式发送时， LAPIC通过LAPICID来判断该中断是否由自己接收。

  **Logical模式**：在该模式下，中断消息中的DestinationField包含的不是LAPICID，而 是被称为MDA（Message Destination Address，消息目的地地址）的信息。此时， LAPIC需 要两个额外的寄存器来判断自己是否为中断消息的目的地，它们是LDR和DFR。

  LDR格式：

  ![](http://o8xc4jzcp.bkt.clouddn.com/LDR-format.PNG)

  LDR全称是LogicalDestinationRegister，逻辑目的地寄存器。该寄存器包含一个8bit 的逻辑APICID（注意区分， 它和LAPICID不是一个东西） ，在Logical模式下用于和MDA 匹配。 LDR的格式由DFR指定。

  DFR格式：

  ![](http://o8xc4jzcp.bkt.clouddn.com/DFR-format.PNG)

  DFR， DestinationFormatRegister，目的地格式寄存器。该寄存器包含一个4bit的mode 字段，用于指定LDR中的LogicalAPICID用何种方式与MDA匹配。通过这两个寄存器的 配合， Logical模式又被分为了Flat与Cluster两种模式。

  **Flat模式**： DFR的model值为1111b，此时， LAPIC将MDA与LDR的logicalAPICID 做位与， 如结果不为0则接收中断。LogicalAPICID中每个bit代表一个LAPIC， 故8bit 最多代表8个CPU。

  **Cluster模式**： DFR的model值为0000b。 Cluster模式又分为两种模式： **Flat Cluster**模式和 **HierarchicalCluster**模式。 

  ​	 **FlatCluster模式**：该模式只支持P6架构和Pentium系列CPU，并假定所有APIC 通过 APIC BUS通讯。该模式将 MDA编码为两个部分，高4bit为簇号，低 4bit 标识LAPIC在该簇内的ID（每个bit代表一个LAPIC， 故一个簇最多有4个LAPIC）。 与之对应， LDR的logical APICID也被编码成同样两个部分。 工作在该模式时， LAPIC先将MDA的高4bit和LogicalAPICID的高4bit比较，以确定自己是否是中断的目的簇。若是，将MDA的低4bit与Logical APICID的低4bit位与，若值不为0则接收中断，否则拒绝。 通过这种方法，高4bit的簇号可以表示15个簇，低4bit的ID可以代表簇内 的4个CPU，最多可以支持60个CPU。但由于APIC BUS的限制，具体的说是 APICArbID（ APIC仲裁ID）的限制，该模式最多只支持15个CPU。

  ​	**Hierarchical Cluster模式**：支持P6架构和Pentium系列，以及Xeon、 Pentium4系 列。该模式通过为每个簇引入一个“簇管理器”，将FlatCluster模式中平等的簇构 成一个具有等级结构的分级网络，并最多支持60个CPU。这个话题太远了，相关 spec没有更多资料，就不多做介绍了。    

4. local APIC
  其负责处理IPI(inter-process interrupt)、直接连接的中断处理、接收和处理interrupt message，每个CPU有自己的local APIC。 
  对应I/O APIC和local APIC的组合，其连接方式见下图：
  
  ![](http://o8xc4jzcp.bkt.clouddn.com/IOAPIC&LAPIC)
  
  对于目前的LAPIC来说，它可能从以下几个来源接收到中断：
- Locally connected I/O devices：这个主要是指通过local interrupt pins (LINT0 and LINT1)直接和处理器相连的I/O设备

- APIC timer generated interrupts：LAPIC可以通过编程设置某个counter，在固定时间内向处理器发送中断

- Performance monitoring counter interrupts：这个是指处理器中的性能计数器在发生overflow事件的时候向处理器发送中断进行通知

- Thermal Sensor interrupts：这个是由温度传感器触发的中断

- APIC internal error interrupts：这个是LAPIC内部错误触发的中断

- Externally connected I/O devices：这个是指外部设备通过IOAPIC和LAPIC进行相连

- Inter-processor interrupts (IPIs)：这个是指处理器之间通过IPI的方式进行中断的发送和接收

  其中，前面五种中断来源被称为本地中断源（local interrupt sources），LAPIC会预先在Local Vector Table (LVT)表中设置好相应的中断递送（delivery）方案，在接收到这些本地中断源的时候根据LVT中的方案对相关中断进行递送。

  除此之外，对于从IOAPIC中发送过来的外部中断，以及从其它处理器中发过来的IPI中断，LAPIC会直接将该中断交给本地的处理器进行处理。而如果需要向其它处理器发送IPI，则可以通过写LAPIC中的ICR寄存器完成。这部分这里就不详述，直接看文档就可以了。

  先了解下LAPIC的三个寄存器：

- IRR(256bit):中断请求寄存器，如果第`n`位的bit被置上，则代表LAPIC已接收vector为`n`的中断，但还未交CPU处理。 

- ISR(256bit)：中断服务寄存器，如果第`n`位的bit被置上，则代表CPU已开始处理vector为`n`的中断，但还未完成。 

- EOI(32bit)

  下面看看LAPIC接受到IOAPIC传递的中断消息后，发生了什么。

  - 通过中断消息的destination field字段，确定该中断是否是发送给自己的；
  - 如果该中断的delivery mode为 NMI、SMI、INIT、ExtINT、SIPI，直接交由CPU处理；
  - 如果不为以上所列举的中断（只剩fixed？），则将IRR中相应的bit置一；
  - 当中断被pending到IRR寄存器中后，根据TPR和PPR寄存器，判断当前最高优先级的中断是否能发送给CPU进行处理，并将ISR寄存器中相应的bit置一；
  - 软件写EOI寄存器通知中断处理完成。如果中断为level触发，该EOI广播到所有IOAPIC，NMI、SMI、INIT、ExtINT、SIPI类型中断无需写EOI。



针对X86中断控制器硬件和linux对这些硬件的初始化，在《interrupt in linux》中有很详细的描述。
